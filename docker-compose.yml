version: '3.8'

services:
  zookeeper:
    image: confluentinc/cp-zookeeper:7.5.0
    hostname: zookeeper
    container_name: zookeeper
    ports:
      - "2181:2181"
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000

  kafka:
    image: confluentinc/cp-kafka:7.5.0
    hostname: kafka
    container_name: kafka
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:29092,PLAINTEXT_HOST://localhost:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0

  kafka-connect:
    image: confluentinc/cp-kafka-connect:7.5.0
    hostname: kafka-connect
    container_name: kafka-connect
    depends_on:
      - kafka
    ports:
      - "8083:8083"
    environment:
      CONNECT_BOOTSTRAP_SERVERS: 'kafka:29092'
      CONNECT_REST_ADVERTISED_HOST_NAME: kafka-connect
      CONNECT_REST_PORT: 8083
      CONNECT_GROUP_ID: connect-cluster
      CONNECT_CONFIG_STORAGE_TOPIC: docker-connect-configs
      CONNECT_CONFIG_STORAGE_REPLICATION_FACTOR: 1
      CONNECT_OFFSET_FLUSH_INTERVAL_MS: 10000
      CONNECT_OFFSET_STORAGE_TOPIC: docker-connect-offsets
      CONNECT_OFFSET_STORAGE_REPLICATION_FACTOR: 1
      CONNECT_STATUS_STORAGE_TOPIC: docker-connect-status
      CONNECT_STATUS_STORAGE_REPLICATION_FACTOR: 1
      CONNECT_KEY_CONVERTER: org.apache.kafka.connect.storage.StringConverter
      CONNECT_VALUE_CONVERTER: org.apache.kafka.connect.storage.StringConverter
      KAFKA_HEAP_OPTS: "-Xms256m -Xmx512m"
    volumes:
      - /tmp:/tmp

  # Test our reconciliation logic
  connector-reconcile:
    image: python:3.11-slim
    depends_on:
      - kafka-connect
    environment:
      CONNECT_REST_URL: "http://kafka-connect:8083"
    volumes:
      - ./connectors:/config/connectors:ro
    command: >
      bash -c "
        # Wait for Kafka Connect to be ready
        until curl -f http://kafka-connect:8083/connectors; do
          echo 'Waiting for Kafka Connect REST API...'
          sleep 2
        done
        
        # Run our reconciliation script
        python - <<'PY'
        import json
        import os
        import pathlib
        import time
        import urllib.error
        import urllib.request

        CONNECT_URL = os.environ.get('CONNECT_REST_URL', 'http://localhost:8083')
        HEADERS = {'Content-Type': 'application/json'}

        def send_json(path: str, payload: dict, method: str = 'POST') -> None:
            data = json.dumps(payload).encode('utf-8')
            req = urllib.request.Request(path, data=data, headers=HEADERS, method=method)
            with urllib.request.urlopen(req) as resp:
                print(f'{method} {path}: {resp.status}')
                return resp.read()

        def upsert_connector(connector: dict) -> None:
            name = connector.get('name')
            if not name:
                raise ValueError('Connector definition missing name')
            config = connector.get('config') or {}
            payload = {'name': name, 'config': config}
            put_path = f'{CONNECT_URL}/connectors/{name}/config'
            try:
                send_json(put_path, config, method='PUT')
                print(f'Updated connector {name}')
            except urllib.error.HTTPError as err:
                if err.code == 404:
                    create_path = f'{CONNECT_URL}/connectors'
                    send_json(create_path, payload, method='POST')
                    print(f'Created connector {name}')
                else:
                    raise

        def load_connector_documents(base_path: pathlib.Path):
            for file_path in sorted(base_path.iterdir()):
                if not file_path.is_file():
                    continue
                text = file_path.read_text(encoding='utf-8')
                if not text.strip():
                    continue
                try:
                    data = json.loads(text)
                except json.JSONDecodeError:
                    print(f'Skipping {file_path}: not valid JSON')
                    continue
                if isinstance(data, dict) and 'connectors' in data:
                    for connector in data.get('connectors', []):
                        yield connector
                else:
                    yield data

        def main():
            config_dir = pathlib.Path('/config/connectors')
            print(f'Loading connectors from {config_dir}')
            for connector in load_connector_documents(config_dir):
                print(f'Processing connector: {connector}')
                upsert_connector(connector)

        if __name__ == '__main__':
            main()
        PY
        
        echo 'Reconciliation complete!'
        sleep 300  # Keep container running
      "